using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

using Microsoft.Extensions.DependencyInjection;

using Serilog;

namespace Modix.Common.Messaging
{
    /// <summary>
    /// Describes an object that publishes and dispatches application-wide notifications.
    /// </summary>
    public interface IMediator
    {
        /// <summary>
        /// Dispatches a notification to be handled by all registered <see cref="INotificationHandler{TNotification}"/> objects.
        /// on a new logical application thread. I.E. handlers for the notification are executed within a new <see cref="IServiceScope"/>
        /// and synchronized through a new <see cref="Task"/> that will run in parallel to the current one, on the <see cref="ThreadPool"/>.
        /// Note that exceptions thrown by and handler of the notification will be logged, and will not affect the execution of other handlers for the notification.
        /// </summary>
        /// <typeparam name="TNotification">The type of notification to be dispatched.</typeparam>
        /// <param name="notification">The notification data to be dispatched.</param>
        void Dispatch<TNotification>(TNotification notification) where TNotification : INotification;

        /// <summary>
        /// Publishes a notification to be handled by all registered <see cref="INotificationHandler{TNotification}"/> objects.
        /// </summary>
        /// <typeparam name="TNotification">The type of notification to be published.</typeparam>
        /// <param name="notification">The notification data to be published.</param>
        /// <param name="cancellationToken">A token to cancel the asynchronous operation.</param>
        /// <returns>A <see cref="Task"/> that will complete when all handlers have completed handling the notification.</returns>
        Task PublishAsync<TNotification>(TNotification notification, CancellationToken cancellationToken = default) where TNotification : INotification;

        /// <summary>
        /// Publishes a request to be handled by a registered <see cref="IRequestHandler{TRequest, TResponse}"/> object.
        /// </summary>
        /// <typeparam name="TRequest">The type of request to be published.</typeparam>
        /// <typeparam name="TResponse">The type of response to be generated by the handler.</typeparam>
        /// <param name="request">The request data to be published.</param>
        /// <param name="cancellationToken">A token to cancel the asynchronous operation.</param>
        /// <returns>
        /// A <see cref="Task"/> that will complete when the handler has completed handling the request,
        /// containing the generated response data.
        /// </returns>
        Task<TResponse> PublishAsync<TRequest, TResponse>(TRequest request, CancellationToken cancellationToken = default) where TRequest : IRequest<TResponse>;
    }

    /// <inheritdoc />
    public class Mediator : IMediator
    {
        /// <summary>
        /// Constructs a new <see cref="Mediator"/> with the given dependencies.
        /// </summary>
        /// <param name="serviceProvider">The value to use for <see cref="ServiceProvider"/>.</param>
        public Mediator(IServiceProvider serviceProvider)
        {
            ServiceProvider = serviceProvider;
        }

        /// <inheritdoc />
        public void Dispatch<TNotification>(TNotification notification) where TNotification : INotification
            #pragma warning disable CS4014
            => DispatchAsync(notification);
            #pragma warning restore CS4014

        /// <inheritdoc />
        public async Task PublishAsync<TNotification>(TNotification notification, CancellationToken cancellationToken = default) where TNotification : INotification
        {
            if (notification == null)
                throw new ArgumentNullException(nameof(notification));

            foreach (var handler in ServiceProvider.GetServices<INotificationHandler<TNotification>>())
                await handler.HandleNotificationAsync(notification, cancellationToken);
        }

        /// <inheritdoc />
        public Task<TResponse> PublishAsync<TRequest, TResponse>(TRequest request, CancellationToken cancellationToken = default) where TRequest : IRequest<TResponse>
        {
            if (request == null)
                throw new ArgumentNullException(nameof(request));

            return ServiceProvider.GetRequiredService<IRequestHandler<TRequest, TResponse>>()
                .HandleRequestAsync(request, cancellationToken);
        }

        /// <summary>
        /// An <see cref="IServiceProvider"/> to be used to retrieve message handlers.
        /// </summary>
        internal protected IServiceProvider ServiceProvider { get; }

        // For testing
        internal async Task DispatchAsync<TNotification>(TNotification notification) where TNotification : INotification
        {
            if (notification == null)
                throw new ArgumentNullException(nameof(notification));

            using (var serviceScope = ServiceProvider.CreateScope())
            {
                var logger = serviceScope.ServiceProvider.GetService<ILogger>();

                foreach (var handler in serviceScope.ServiceProvider.GetServices<INotificationHandler<TNotification>>())
                {
                    try
                    {
                        await handler.HandleNotificationAsync(notification);
                    }
                    catch (Exception ex)
                    {
                        logger?.Error(ex, "An unexpected error occurred within a handler for a dispatched message: {notification}", notification);
                    }
                }
            }
        }
    }
}
